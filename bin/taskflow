#!/usr/bin/env node
/**
 * taskflow — CLI entry point (taskflow-011)
 *
 * Commands:
 *   taskflow setup               Interactive first-run onboarding
 *   taskflow status              Pretty terminal summary (all projects)
 *   taskflow export              JSON export to stdout
 *   taskflow sync <mode>         Sync markdown ↔ SQLite (modes: files-to-db | db-to-files | check)
 *   taskflow init                Bootstrap SQLite schema
 *   taskflow help                Show this help
 */

import { DatabaseSync } from 'node:sqlite'
import { existsSync, mkdirSync, writeFileSync, readFileSync } from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const SCRIPTS = path.resolve(__dirname, '..', 'scripts')

// Workspace / DB resolution
const workspace = process.env.OPENCLAW_WORKSPACE || process.cwd()
const dbPath    = path.join(workspace, 'memory', 'taskflow.sqlite')

// ── Colour / terminal helpers ─────────────────────────────────────────────
const isTTY = process.stdout.isTTY
const c = {
  reset:  isTTY ? '\x1b[0m'  : '',
  bold:   isTTY ? '\x1b[1m'  : '',
  dim:    isTTY ? '\x1b[2m'  : '',
  green:  isTTY ? '\x1b[32m' : '',
  yellow: isTTY ? '\x1b[33m' : '',
  blue:   isTTY ? '\x1b[34m' : '',
  cyan:   isTTY ? '\x1b[36m' : '',
  red:    isTTY ? '\x1b[31m' : '',
  gray:   isTTY ? '\x1b[90m' : '',
}

function badge(text, color) {
  return `${color}${text}${c.reset}`
}

// Unicode block progress bar  ▏▎▍▌▋▊▉█
const BLOCKS = ' ▏▎▍▌▋▊▉█'

function progressBar(pct, width = 20) {
  const filled   = Math.round((pct / 100) * width * 8)
  const fullBlks = Math.floor(filled / 8)
  const partial  = filled % 8
  const empty    = width - fullBlks - (partial > 0 ? 1 : 0)

  return (
    '█'.repeat(fullBlks) +
    (partial > 0 ? BLOCKS[partial] : '') +
    '░'.repeat(Math.max(0, empty))
  )
}

function statusColor(status) {
  switch (status) {
    case 'active':  return c.green
    case 'paused':  return c.yellow
    case 'done':    return c.gray
    default:        return c.reset
  }
}

// ── Commands ──────────────────────────────────────────────────────────────

// --- status ------------------------------------------------------------------
function cmdStatus() {
  if (!existsSync(dbPath)) {
    console.error(`${c.red}✗${c.reset} DB not found at: ${dbPath}`)
    console.error(`  Run ${c.bold}taskflow setup${c.reset} to get started, or ${c.bold}taskflow init${c.reset} to bootstrap the database.`)
    process.exit(1)
  }

  const db = new DatabaseSync(dbPath)
  db.exec('PRAGMA foreign_keys = ON')

  const projects = db
    .prepare('SELECT id, name, description, status FROM projects ORDER BY id')
    .all()

  if (projects.length === 0) {
    console.log(`${c.dim}No projects found. Add entries to PROJECTS.md and run: taskflow sync files-to-db${c.reset}`)
    return
  }

  const countRows = db
    .prepare('SELECT project_id, status, COUNT(*) AS cnt FROM tasks_v2 GROUP BY project_id, status')
    .all()

  const countsByProject = {}
  for (const row of countRows) {
    if (!countsByProject[row.project_id]) countsByProject[row.project_id] = {}
    countsByProject[row.project_id][row.status] = row.cnt
  }

  console.log()
  console.log(`${c.bold}${c.cyan}  TaskFlow — Project Overview${c.reset}`)
  console.log(`${c.gray}  ${'─'.repeat(60)}${c.reset}`)

  for (const p of projects) {
    const counts = countsByProject[p.id] || {}
    const ip  = counts.in_progress        ?? 0
    const pv  = counts.pending_validation ?? 0
    const bl  = counts.backlog            ?? 0
    const bk  = counts.blocked            ?? 0
    const dn  = counts.done               ?? 0
    const tot = ip + pv + bl + bk + dn
    const pct = tot > 0 ? Math.round((dn / tot) * 10000) / 100 : 0

    const statusStr = badge(` ${p.status} `, statusColor(p.status))

    console.log()
    console.log(`  ${c.bold}${p.name}${c.reset}  ${statusStr}  ${c.gray}(${p.id})${c.reset}`)
    if (p.description) {
      console.log(`  ${c.dim}${p.description}${c.reset}`)
    }

    // Progress bar
    const bar     = progressBar(pct, 24)
    const pctStr  = pct.toFixed(1).padStart(5)
    console.log(`  ${c.green}${bar}${c.reset}  ${c.bold}${pctStr}%${c.reset} done  ${c.gray}(${tot} tasks)${c.reset}`)

    // Task counts row
    const parts = []
    if (ip)  parts.push(`${c.blue}${ip} in-progress${c.reset}`)
    if (pv)  parts.push(`${c.yellow}${pv} pending-validation${c.reset}`)
    if (bk)  parts.push(`${c.red}${bk} blocked${c.reset}`)
    if (bl)  parts.push(`${c.dim}${bl} backlog${c.reset}`)
    if (dn)  parts.push(`${c.gray}${dn} done${c.reset}`)
    if (parts.length) {
      console.log(`  ${parts.join('  ')}`)
    } else {
      console.log(`  ${c.dim}no tasks yet${c.reset}`)
    }
  }

  console.log()
  console.log(`${c.gray}  ${'─'.repeat(60)}${c.reset}`)
  console.log(`${c.dim}  Workspace: ${workspace}${c.reset}`)
  console.log()
}

// --- export ------------------------------------------------------------------
async function cmdExport() {
  // Import the export script — its top-level code runs and writes JSON to stdout.
  await import(path.join(SCRIPTS, 'export-projects-overview.mjs'))
}

// --- sync --------------------------------------------------------------------
async function cmdSync(mode) {
  const VALID_MODES = ['files-to-db', 'db-to-files', 'check']
  if (!VALID_MODES.includes(mode)) {
    console.error(`${c.red}✗${c.reset} Unknown sync mode: ${JSON.stringify(mode)}`)
    console.error(`  Valid modes: ${VALID_MODES.join(' | ')}`)
    process.exit(1)
  }

  const syncScript = path.join(SCRIPTS, 'task-sync.mjs')
  if (!existsSync(syncScript)) {
    console.error(`${c.red}✗${c.reset} task-sync.mjs not found at: ${syncScript}`)
    process.exit(1)
  }

  // task-sync.mjs reads process.argv[2] for the mode.
  process.argv[2] = mode
  await import(syncScript)
}

// --- init --------------------------------------------------------------------
async function cmdInit() {
  const initScript = path.join(SCRIPTS, 'init-db.mjs')
  if (!existsSync(initScript)) {
    console.error(`${c.red}✗${c.reset} init-db.mjs not found at: ${initScript}`)
    process.exit(1)
  }
  await import(initScript)
}

// --- setup helpers -----------------------------------------------------------

/** Convert a human name to a lowercase-hyphenated slug. */
function toSlug(name) {
  return name
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, '')
    .replace(/[\s_]+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-+|-+$/g, '')
}

/** Print a summary of what was created and what to do next. */
function printSetupSummary(createdFiles) {
  console.log()
  console.log(`${c.bold}${c.green}  ✓ TaskFlow setup complete!${c.reset}`)
  console.log()
  if (createdFiles.length > 0) {
    console.log(`${c.bold}  Created:${c.reset}`)
    for (const f of createdFiles) {
      console.log(`    ${c.cyan}${f}${c.reset}`)
    }
    console.log()
  }
  console.log(`${c.bold}  Next steps:${c.reset}`)
  console.log(`    ${c.cyan}taskflow status${c.reset}           — view all projects`)
  console.log(`    ${c.cyan}taskflow sync files-to-db${c.reset} — re-sync after editing markdown`)
  console.log(`    ${c.cyan}taskflow help${c.reset}             — full command reference`)
  console.log()
}

/**
 * Offer to install (or describe) the periodic-sync LaunchAgent on macOS,
 * or print cron instructions on Linux.
 *
 * @param {Function|null} ask   - readline ask helper (null when non-interactive)
 */
async function offerLaunchAgent(ask, autoYes = false) {
  const os = process.platform

  if (os !== 'darwin') {
    console.log()
    console.log(`${c.dim}  Linux detected. For periodic auto-sync, add to crontab (crontab -e):${c.reset}`)
    const syncScript = path.join(workspace, 'taskflow', 'scripts', 'task-sync.mjs')
    console.log(`  ${c.gray}* * * * * OPENCLAW_WORKSPACE=${workspace} ${process.execPath} ${syncScript} files-to-db${c.reset}`)
    return
  }

  // macOS — offer LaunchAgent
  const plistDest = path.join(
    process.env.HOME || '',
    'Library', 'LaunchAgents', 'com.taskflow.sync.plist'
  )

  if (existsSync(plistDest)) {
    console.log(`  ${c.green}✓${c.reset} LaunchAgent already installed at ${plistDest}`)
    return
  }

  const tmplPath = path.join(__dirname, '..', 'launchagents', 'com.taskflow.sync.plist.tmpl')
  if (!existsSync(tmplPath)) return

  // Non-interactive without --yes: skip LaunchAgent silently
  if (!ask && !autoYes) return

  // Interactive: prompt user
  if (ask && !autoYes) {
    console.log()
    const ans = (await ask('Install LaunchAgent for automatic 60s sync? [Y/n] ')).trim().toLowerCase()
    if (ans === 'n') return
  }

  try {
    const nodeBin = process.execPath
    const plistContent = readFileSync(tmplPath, 'utf8')
      .replace(/\{\{workspace\}\}/g, workspace)
      .replace(/<string>\/usr\/local\/bin\/node<\/string>/, `<string>${nodeBin}</string>`)

    writeFileSync(plistDest, plistContent, 'utf8')
    console.log(`  ${c.green}created${c.reset} ${plistDest}`)

    // Ensure logs dir exists
    const logsDir = path.join(workspace, 'logs')
    if (!existsSync(logsDir)) {
      mkdirSync(logsDir, { recursive: true })
      console.log(`  ${c.green}created${c.reset} logs/`)
    }

    // Load the agent
    const { execSync } = await import('node:child_process')
    try {
      execSync(`launchctl load "${plistDest}"`, { stdio: 'pipe' })
      console.log(`  ${c.green}loaded${c.reset}  com.taskflow.sync LaunchAgent (sync every 60s)`)
    } catch {
      console.log(`  ${c.yellow}!${c.reset} Could not load LaunchAgent automatically. Run manually:`)
      console.log(`    launchctl load "${plistDest}"`)
    }
  } catch (e) {
    console.log(`  ${c.yellow}!${c.reset} LaunchAgent install failed: ${e.message}`)
  }
}

/**
 * Offer to set up Apple Notes sync (macOS only).
 * Creates the note via apple-notes-export.mjs and saves the ID to config.
 *
 * @param {Function|null} ask  - readline ask helper
 */
async function offerAppleNotes(ask) {
  if (process.platform !== 'darwin') return

  if (!ask) return   // non-interactive: skip silently

  console.log()
  const ans = (await ask(
    'Set up Apple Notes sync? This creates a shared note that stays updated with your project status. (y/N) '
  )).trim().toLowerCase()

  if (ans !== 'y') return

  const notesScript = path.join(SCRIPTS, 'apple-notes-export.mjs')
  if (!existsSync(notesScript)) {
    console.log(`  ${c.yellow}!${c.reset} apple-notes-export.mjs not found — skipping Notes setup.`)
    return
  }

  console.log()
  console.log(`  ${c.bold}Creating Apple Note…${c.reset}`)
  try {
    await import(notesScript)
    console.log()
    console.log(`  ${c.green}✓${c.reset} Apple Notes sync configured.`)
    console.log(`    Run ${c.cyan}taskflow notes${c.reset} to update manually.`)
    console.log(`    For hourly auto-refresh, add a LaunchAgent or cron:`)
    console.log(`    ${c.gray}0 * * * * OPENCLAW_WORKSPACE=${workspace} ${process.execPath} ${notesScript}${c.reset}`)
  } catch (e) {
    console.log(`  ${c.yellow}!${c.reset} Apple Notes setup failed: ${e.message}`)
    console.log(`    You can retry anytime with: ${c.cyan}taskflow notes${c.reset}`)
  }
}

// --- setup -------------------------------------------------------------------
async function cmdSetup(args) {
  // ── Parse CLI flags (non-interactive mode) ─────────────────────────────
  const nameIdx = args.indexOf('--name')
  const descIdx = args.indexOf('--desc')
  const nonInteractiveName = nameIdx !== -1 ? args[nameIdx + 1] : null
  const nonInteractiveDesc = descIdx !== -1 ? args[descIdx + 1] : null
  const nonInteractive = nonInteractiveName !== null
  const skipLaunchAgent = args.includes('--no-launchagent')
  const autoYes = args.includes('--yes') || args.includes('-y')

  // ── Common paths ────────────────────────────────────────────────────────
  const projectsFile = path.join(workspace, 'PROJECTS.md')
  const tasksDir     = path.join(workspace, 'tasks')
  const plansDir     = path.join(workspace, 'plans')
  const memoryDir    = path.join(workspace, 'memory')

  // ── Readline setup ──────────────────────────────────────────────────────
  let rl  = null
  let ask = null

  if (!nonInteractive) {
    const { createInterface } = await import('node:readline/promises')
    rl = createInterface({ input: process.stdin, output: process.stdout })
    rl.on('SIGINT', () => {
      console.log(`\n\n${c.yellow}Setup interrupted. No changes were committed.${c.reset}\n`)
      rl.close()
      process.exit(0)
    })
    ask = (q) => rl.question(`${c.cyan}?${c.reset} ${q}`)
  }

  const close = () => { if (rl) { rl.close(); rl = null } }

  // ── Header ──────────────────────────────────────────────────────────────
  console.log()
  console.log(`${c.bold}${c.cyan}  TaskFlow Setup${c.reset}`)
  console.log(`${c.gray}  ${'─'.repeat(52)}${c.reset}`)
  console.log(`  Workspace: ${c.bold}${workspace}${c.reset}`)
  console.log()

  // ── Detect current state ────────────────────────────────────────────────
  const hasProjects = existsSync(projectsFile)
  const hasDb       = existsSync(dbPath)

  // ── Scenario 1: Fully set up ────────────────────────────────────────────
  if (hasProjects && hasDb) {
    console.log(`${c.green}✓${c.reset} Already set up — PROJECTS.md and DB both present.`)
    console.log()
    cmdStatus()

    if (!nonInteractive) {
      const ans = await ask('Re-sync markdown → DB now? [y/N] ')
      close()
      if (ans.trim().toLowerCase() === 'y') {
        console.log()
        await cmdSync('files-to-db')
        console.log()
        console.log(`${c.green}✓${c.reset} Sync complete.`)
        console.log()
      }
    }
    return
  }

  // ── Scenario 2: PROJECTS.md exists but no DB ────────────────────────────
  if (hasProjects && !hasDb) {
    console.log(`${c.yellow}!${c.reset} PROJECTS.md found but no SQLite DB.`)

    if (!nonInteractive) {
      const ans = await ask('Initialize DB and sync markdown → DB now? [Y/n] ')
      if (ans.trim().toLowerCase() === 'n') {
        close()
        console.log()
        console.log('Aborted — no changes made.')
        console.log()
        return
      }
    }

    console.log()
    await cmdInit()
    console.log()
    await cmdSync('files-to-db')

    if (!skipLaunchAgent) await offerLaunchAgent(ask, autoYes)
    await offerAppleNotes(ask)
    close()
    printSetupSummary([])
    return
  }

  // ── Scenario 3: Clean slate ──────────────────────────────────────────────
  console.log(`${c.dim}  No existing workspace detected. Starting fresh.${c.reset}`)
  console.log()

  // Create required directories
  const createdFiles = []
  for (const [dir, label] of [[tasksDir, 'tasks/'], [plansDir, 'plans/'], [memoryDir, 'memory/']]) {
    if (!existsSync(dir)) {
      mkdirSync(dir, { recursive: true })
      console.log(`  ${c.green}created${c.reset} ${label}`)
      createdFiles.push(label)
    }
  }

  // Collect project definitions
  const projects = []

  if (nonInteractive) {
    // Non-interactive: single project from flags
    projects.push({ name: nonInteractiveName, desc: nonInteractiveDesc || '' })
  } else {
    // Interactive: first project
    const firstName = (await ask("What's your first project name? ")).trim()
    if (!firstName) {
      close()
      console.log(`\n${c.red}✗${c.reset} Project name is required. Aborting.`)
      console.log()
      process.exit(1)
    }
    const firstDesc = (await ask('One-liner description (optional, press Enter to skip): ')).trim()
    projects.push({ name: firstName, desc: firstDesc })

    // Loop for additional projects
    let addMore = true
    while (addMore) {
      const moreAns = (await ask('Add another project? [y/N] ')).trim().toLowerCase()
      if (moreAns !== 'y') {
        addMore = false
      } else {
        const n = (await ask('  Project name: ')).trim()
        if (n) {
          const d = (await ask('  Description (optional): ')).trim()
          projects.push({ name: n, desc: d })
        }
      }
    }
  }

  // Load tasks template
  const tasksTmplPath = path.join(__dirname, '..', 'templates', 'tasks.md.tmpl')
  let tasksTmpl = null
  try { tasksTmpl = readFileSync(tasksTmplPath, 'utf8') } catch { /* use fallback */ }

  // Build PROJECTS.md content
  let projectsMd = `# Projects\n\n`
  projectsMd += `<!-- ============================================================
  PROJECTS.md — Project Registry
  ============================================================

  FORMAT: One ## block per project. The slug (## heading text)
  is the canonical project ID used in task IDs, file names,
  and SQLite foreign keys. Keep it lowercase and hyphenated.

  FIELDS:
    Name        Human-readable display name (any capitalization).
    Status      One of: active | paused | done
    Description One-sentence summary of the project's purpose.
  ============================================================ -->\n\n`

  for (const p of projects) {
    const slug = toSlug(p.name)

    // Append project block
    projectsMd += `## ${slug}\n- Name: ${p.name}\n- Status: active\n`
    if (p.desc) projectsMd += `- Description: ${p.desc}\n`
    projectsMd += '\n'

    // Create tasks file from template (or fallback)
    const tasksFile = path.join(tasksDir, `${slug}-tasks.md`)
    const tasksContent = tasksTmpl
      ? tasksTmpl
          .replace(/\{\{Project Name\}\}/g, p.name)
          .replace(/\{\{slug\}\}/g, slug)
      : `# ${p.name} — Tasks\n\n## In Progress\n\n## Pending Validation\n\n## Backlog\n\n- [ ] (task:${slug}-001) [P2] First task for this project\n\n## Blocked\n\n## Done\n`

    writeFileSync(tasksFile, tasksContent, 'utf8')
    createdFiles.push(`tasks/${slug}-tasks.md`)
    console.log(`  ${c.green}created${c.reset} tasks/${slug}-tasks.md`)
  }

  // Write PROJECTS.md
  writeFileSync(projectsFile, projectsMd, 'utf8')
  createdFiles.push('PROJECTS.md')
  console.log(`  ${c.green}created${c.reset} PROJECTS.md`)
  console.log()

  // Init DB
  console.log(`${c.bold}  Initializing database…${c.reset}`)
  await cmdInit()
  console.log()

  // Sync files → DB
  console.log(`${c.bold}  Syncing markdown → DB…${c.reset}`)
  await cmdSync('files-to-db')

  // Offer LaunchAgent / cron (interactive only — rl still open)
  if (!skipLaunchAgent) await offerLaunchAgent(ask, autoYes)
  await offerAppleNotes(ask)
  close()

  printSetupSummary(createdFiles)
}

// --- notes -------------------------------------------------------------------
async function cmdNotes() {
  const notesScript = path.join(SCRIPTS, 'apple-notes-export.mjs')
  if (!existsSync(notesScript)) {
    console.error(`${c.red}✗${c.reset} apple-notes-export.mjs not found at: ${notesScript}`)
    process.exit(1)
  }
  await import(notesScript)
}

// --- help --------------------------------------------------------------------
function cmdHelp() {
  console.log(`
${c.bold}taskflow${c.reset} — TaskFlow CLI

${c.bold}USAGE${c.reset}
  taskflow <command> [options]

${c.bold}COMMANDS${c.reset}
  ${c.cyan}setup${c.reset}                     Interactive first-run onboarding. Creates workspace
                            directories, PROJECTS.md, task files, initializes the
                            DB, syncs, and optionally installs the LaunchAgent.
    ${c.dim}--name <name>${c.reset}           Non-interactive: project name (skips all prompts)
    ${c.dim}--desc <desc>${c.reset}           Non-interactive: project description
    ${c.dim}--no-launchagent${c.reset}        Skip LaunchAgent / cron prompt
    ${c.dim}--yes, -y${c.reset}              Auto-accept all yes/no prompts

  ${c.cyan}status${c.reset}                    Pretty terminal summary of all projects with task counts
                            and progress bars.

  ${c.cyan}export${c.reset}                    Output a full JSON snapshot of all projects and tasks to
                            stdout. Pipe to a file for dashboard consumption.

  ${c.cyan}sync${c.reset} <mode>               Sync task markdown files ↔ SQLite.
    ${c.dim}files-to-db${c.reset}             Parse markdown, write to DB (markdown is authoritative)
    ${c.dim}db-to-files${c.reset}             Regenerate markdown from DB state
    ${c.dim}check${c.reset}                   Detect drift, exit 1 if mismatch (good for CI/cron)

  ${c.cyan}init${c.reset}                      Bootstrap (or re-bootstrap) the SQLite schema. Idempotent.

  ${c.cyan}notes${c.reset}                     Push current project status to Apple Notes (macOS only).
                            Creates a new note on first run; edits in-place on subsequent
                            runs (preserves any share link). Note ID is saved to
                            \$OPENCLAW_WORKSPACE/taskflow.config.json.

  ${c.cyan}help${c.reset}                      Show this message.

${c.bold}ENVIRONMENT${c.reset}
  OPENCLAW_WORKSPACE        Root workspace directory (default: cwd)
                            DB is resolved as \$OPENCLAW_WORKSPACE/memory/taskflow.sqlite

${c.bold}EXAMPLES${c.reset}
  taskflow setup
  taskflow setup --name "My Project" --desc "A cool thing" --no-launchagent
  taskflow init
  taskflow sync files-to-db
  taskflow status
  taskflow export > /tmp/projects.json
  taskflow sync check && echo "in sync"
  taskflow notes
`)
}

// ── Dispatch ─────────────────────────────────────────────────────────────
const [,, cmd, ...args] = process.argv

switch (cmd) {
  case 'setup':
    await cmdSetup(args)
    break

  case 'status':
    cmdStatus()
    break

  case 'export':
    await cmdExport()
    break

  case 'sync':
    await cmdSync(args[0] || 'check')
    break

  case 'init':
    await cmdInit()
    break

  case 'notes':
    await cmdNotes()
    break

  case 'help':
  case '--help':
  case '-h':
    cmdHelp()
    break

  case undefined:
    // No args: show status as a sensible default
    cmdStatus()
    break

  default:
    console.error(`${c.red}✗${c.reset} Unknown command: ${JSON.stringify(cmd)}`)
    console.error(`  Run ${c.bold}taskflow help${c.reset} for usage.`)
    process.exit(1)
}
